package main

import (
<<<<<<< HEAD:cmd/ingress/main.go.old
	"bufio"
	"fmt"
	//"github.com/open-bastion/open-bastion/internal/config"
	"golang.org/x/crypto/ssh"
	"golang.org/x/crypto/ssh/terminal"
	"io/ioutil"
	"log"
	"net"
	"os"
	//"os/signal"
)

func main() {
	//args := os.Args

	// serverConfig := new(config.Config)
	// serverConfig.ParseConfig(args[1])

	// Public key authentication is done by comparing
	// the public key of a received connection
	// with the entries in the authorized_keys file.
	// authorizedKeysBytes, err := ioutil.ReadFile("~/.ssh/authorized_keys")
	// if err != nil {
	// 	log.Fatalf("Failed to load authorized_keys, err: %v", err)
	// }

	// authorizedKeysMap := map[string]bool{}
	// for len(authorizedKeysBytes) > 0 {
	// 	pubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)
	// 	if err != nil {
	// 		log.Fatal(err)
	// 	}

	// 	authorizedKeysMap[string(pubKey.Marshal())] = true
	// 	authorizedKeysBytes = rest
	// }
	authorizedKeysMap := map[string]bool{}
=======
	"github.com/open-bastion/open-bastion/internal/auth"
	"github.com/open-bastion/open-bastion/internal/config"
	"github.com/open-bastion/open-bastion/internal/egress"
	"github.com/open-bastion/open-bastion/internal/ingress"
	"golang.org/x/crypto/ssh"
	"log"
	"net"
	"strconv"
)

func main() {
	var sshServer ingress.Ingress
	var auth auth.Auth
	var config config.Config
>>>>>>> 97a0549... Crated first proto with project structure.:cmd/open-bastion/main.go

	config.ParseConfig("/home/alex/Documents/open-bastion/configs/open-bastion-conf.json")

<<<<<<< HEAD:cmd/ingress/main.go.old
	privateBytes, err := ioutil.ReadFile("/home/alex/Documents/open-bastion/user.key")
	if err != nil {
		log.Fatal("Failed to load private key: ", err)
	}

	private, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("Failed to parse private key: ", err)
	}
=======
	auth.ReadAuthorizedKeysFile(config.AuthorizedKeysFile)
>>>>>>> 97a0549... Crated first proto with project structure.:cmd/open-bastion/main.go

	sshServer.ConfigSSHServer(auth.AuthorizedKeys, "/home/alex/Documents/open-bastion/bastion.key")

	// Once a ServerConfig has been configured, connections can be
	// accepted.
<<<<<<< HEAD:cmd/ingress/main.go.old
	listener, err := net.Listen("tcp", "0.0.0.0:2022")
=======
	log.Println("listen for incoming connections")
	listener, err := net.Listen("tcp", config.ListenAddress+":"+strconv.Itoa(config.ListenPort))
>>>>>>> 97a0549... Crated first proto with project structure.:cmd/open-bastion/main.go
	if err != nil {
		log.Fatal("failed to listen for connection: ", err)
	}
	nConn, err := listener.Accept()
	if err != nil {
		log.Fatal("failed to accept incoming connection: ", err)
	}

	// Before use, a handshake must be performed on the incoming
	// net.Conn.
<<<<<<< HEAD:cmd/ingress/main.go.old
	conn, chans, reqs, err := ssh.NewServerConn(nConn, config)
=======
	hsConn, chans, reqs, err := ssh.NewServerConn(client, sshServer.SSHServerConfig)
>>>>>>> 97a0549... Crated first proto with project structure.:cmd/open-bastion/main.go
	if err != nil {
		log.Fatal("failed to handshake: ", err)
	}
	log.Printf("logged in with key %s", conn.Permissions.Extensions["pubkey-fp"])

	// The incoming Request channel must be serviced.
	go ssh.DiscardRequests(reqs)

	// Service the incoming Channel channel.
	for newChannel := range chans {
		// Channels have a type, depending on the application level
		// protocol intended. In the case of a shell, the type is
		// "session" and ServerShell may be used to present a simple
		// terminal interface.
		log.Printf("channel opened (type=%s)", newChannel.ChannelType())
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}
		channel, _, err := newChannel.Accept()
		if err != nil {
			log.Fatalf("Could not accept channel: %v", err)
		}

<<<<<<< HEAD:cmd/ingress/main.go.old
		term := terminal.NewTerminal(channel, "open-bastion> ")

		go func() {
			defer channel.Close()
			for {
				line, err := term.ReadLine()
				if err != nil {
					break
				}
				fmt.Println(line)
			}
		}()

		//dialssh(term)

	}
}

func dialssh(term *terminal.Terminal) {

	server := "127.0.0.1"
	port := "22"

	server = server + ":" + port
	user := "foo"
	p := "bar"

	var pass = string(p)
	config := &ssh.ClientConfig{
		User: user,
		Auth: []ssh.AuthMethod{
			// ClientAuthPassword wraps a ClientPassword implementation
			// in a type that implements ClientAuth.
			ssh.Password(pass),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}
	conn, err := ssh.Dial("tcp", server, config)
	if err != nil {
		panic("Failed to dial: " + err.Error())
	}
	defer conn.Close()

	// Each ClientConn can support multiple interactive sessions,
	// represented by a Session.
	session, err := conn.NewSession()
	if err != nil {
		panic("Failed to create session: " + err.Error())
	}
	defer session.Close()

	// Set IO
	session.Stdout = os.Stdout
	session.Stderr = os.Stderr
	in, _ := session.StdinPipe()

	// Set up terminal modes
	modes := ssh.TerminalModes{
		ssh.ECHO:          0,     // disable echoing
		ssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud
		ssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud
	}

	// Request pseudo terminal
	if err := session.RequestPty("xterm", 80, 40, modes); err != nil {
		log.Fatalf("request for pseudo terminal failed: %s", err)
	}

	// Start remote shell
	if err := session.Shell(); err != nil {
		log.Fatalf("failed to start shell: %s", err)
	}

	// Accepting commands
	for {
		reader := bufio.NewReader(os.Stdin)
		str, _ := reader.ReadString('\n')
		fmt.Fprint(in, str)
	}

=======
		// jump to new connection
		egress.DialSSH(channel, "alex", "127.0.0.1", 22)
	}
>>>>>>> 97a0549... Crated first proto with project structure.:cmd/open-bastion/main.go
}
